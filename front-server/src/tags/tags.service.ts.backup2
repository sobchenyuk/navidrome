import { Injectable } from '@nestjs/common';
import { Track } from './track.model';
import { TagInput } from './tag.input';
import * as path from 'path';
import * as fs from 'fs/promises';
import { parseFile } from 'music-metadata';
import * as NodeID3 from 'node-id3';
import { createHash } from 'crypto';

@Injectable()
export class TagsService {
  private readonly musicPath = '/music'; // Docker volume mount path
  private readonly supportedExtensions = ['.mp3', '.flac', '.ogg', '.m4a', '.mp4', '.aac', '.wma'];

  private generateTrackId(filePath: string): string {
    return createHash('md5').update(filePath).digest('hex');
  }

  private async scanDirectory(dirPath: string): Promise<string[]> {
    const audioFiles: string[] = [];
    
    try {
      const items = await fs.readdir(dirPath, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = path.join(dirPath, item.name);
        
        if (item.isDirectory()) {
          // Recursively scan subdirectories
          const subFiles = await this.scanDirectory(fullPath);
          audioFiles.push(...subFiles);
        } else if (item.isFile()) {
          // Check if file has supported audio extension
          const ext = path.extname(item.name).toLowerCase();
          if (this.supportedExtensions.includes(ext)) {
            audioFiles.push(fullPath);
          }
        }
      }
    } catch (error) {
      console.error(`Error scanning directory ${dirPath}:`, error);
    }
    
    return audioFiles;
  }

  private async readMetadata(filePath: string): Promise<Track | null> {
    try {
      const metadata = await parseFile(filePath);
      const relativePath = path.relative(this.musicPath, filePath);
      
      // Extract cover art as base64 if available
      let cover: string | undefined;
      if (metadata.common.picture && metadata.common.picture.length > 0) {
        const picture = metadata.common.picture[0];
        cover = `data:${picture.format};base64,${picture.data.toString('base64')}`;
      }
      
      const track: Track = {
        id: this.generateTrackId(relativePath),
        path: relativePath,
        title: metadata.common.title || undefined,
        artist: metadata.common.artist || undefined,
        albumArtist: metadata.common.albumartist || metadata.common.artist || undefined,
        album: metadata.common.album || undefined,
        year: metadata.common.year || undefined,
        trackNumber: metadata.common.track?.no || undefined,
        genre: metadata.common.genre?.[0] || undefined,
        cover,
      };
      
      return track;
    } catch (error) {
      console.error(`Error reading metadata for ${filePath}:`, error);
      return null;
    }
  }

  async findAll(searchPath?: string): Promise<Track[]> {
    try {
      console.log('üîç Scanning for audio files...');
      const scanDir = searchPath ? path.join(this.musicPath, searchPath) : this.musicPath;
      
      // Check if music directory exists
      try {
        await fs.access(scanDir);
      } catch {
        console.warn(`Music directory not found: ${scanDir}`);
        return [];
      }
      
      // Scan for audio files
      const audioFiles = await this.scanDirectory(scanDir);
      console.log(`üìÅ Found ${audioFiles.length} audio files`);
      
      if (audioFiles.length === 0) {
        console.log('No audio files found, returning empty array');
        return [];
      }
      
      // Read metadata for each file
      const tracks: Track[] = [];
      for (const filePath of audioFiles.slice(0, 50)) { // Limit to first 50 files for performance
        const track = await this.readMetadata(filePath);
        if (track) {
          tracks.push(track);
          console.log(`‚úÖ Loaded: ${track.path}`);
        }
      }
      
      console.log(`üéµ Successfully loaded ${tracks.length} tracks`);
      return tracks;
    } catch (error) {
      console.error('Error in findAll:', error);
      return [];
    }
  }

  async findOne(filePath: string): Promise<Track | null> {
    try {
      const fullPath = path.join(this.musicPath, filePath);
      return await this.readMetadata(fullPath);
    } catch (error) {
      console.error(`Error reading single track ${filePath}:`, error);
      return null;
    }
  }

  async updateTags(filePath: string, tagInput: TagInput): Promise<boolean> {
    try {
      const fullPath = path.join(this.musicPath, filePath);
      const ext = path.extname(fullPath).toLowerCase();
      
      console.log(`üè∑Ô∏è Updating tags for ${filePath}:`, tagInput);
      
      if (ext === '.mp3') {
        // Handle MP3 files with node-id3
        const tags = {
          title: tagInput.title,
          artist: tagInput.artist,
          albumArtist: tagInput.albumArtist,
          album: tagInput.album,
          year: tagInput.year?.toString(),
          trackNumber: tagInput.trackNumber?.toString(),
          genre: tagInput.genre,
        };
        
        // Remove undefined values
        Object.keys(tags).forEach(key => {
          if (tags[key] === undefined) {
            delete tags[key];
          }
        });
        
        const success = NodeID3.update(tags, fullPath);
        if (success) {
          console.log(`‚úÖ Successfully updated MP3 tags for ${filePath}`);
          return true;
        } else {
          console.error(`‚ùå Failed to update MP3 tags for ${filePath}`);
          return false;
        }
      } else {
        // For other formats, log the attempt but don't implement yet
        console.log(`‚ö†Ô∏è Tag writing for ${ext} files not yet implemented`);
        return false;
      }
    } catch (error) {
      console.error('Error updating tags:', error);
      return false;
    }
  }

  async uploadCover(filePath: string, coverData: Buffer): Promise<boolean> {
    try {
      // TODO: Implement cover upload using node-id3 or flac-metadata
      console.log(`Uploading cover for ${filePath}`);
      return true;
    } catch (error) {
      console.error('Error uploading cover:', error);
      return false;
    }
  }
}
